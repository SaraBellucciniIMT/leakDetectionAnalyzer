package io;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import org.jbpt.algo.tree.rpst.IRPSTNode;
import org.jbpt.algo.tree.rpst.RPST;
import org.jbpt.algo.tree.tctree.TCType;
import org.jbpt.graph.Fragment;
import org.jbpt.pm.ControlFlow;
import org.jbpt.pm.FlowNode;

/**
 * This is the Exploited RPST class that defines and extended version of the
 * RPST, also called Process Tree (definition 3.1).
 * 
 * @author S. Belluccini
 *
 */
public class ExploitedRPST {

	RPST<ControlFlow<FlowNode>, FlowNode> rpst;

	/**
	 * Constructor for the ExploitedRPST class. It initialize the rpst.
	 * 
	 * @param rpst a refined process structure tree
	 */
	public ExploitedRPST(RPST<ControlFlow<FlowNode>, FlowNode> rpst) {
		this.rpst = rpst;
	}

	/**
	 * Returns the root of the tree
	 * 
	 * @return the root of the tree
	 */
	public ExtendedNode getRoot() {
		return new ExtendedNode(this.rpst.getRoot());
	}

	/**
	 * Checks if the node is a loop or not
	 * 
	 * @param node the input node
	 * @return true if it is a loop, false otherwise
	 */
	public boolean isLoop(ExtendedNode node) {
		if (node.getIRPTNodeAssociated() != null) {
			for (ControlFlow<FlowNode> f : node.getIRPTNodeAssociated().getFragment()) {
				if (f.getV1().equals(node.getIRPTNodeAssociated().getExit())
						&& f.getV2().equals(node.getIRPTNodeAssociated().getEntry()))
					return true;
			}
		}
		return false;
	}
	
	public ExtendedNode theLoop(ExtendedNode node) {
		for (IRPSTNode<ControlFlow<FlowNode>, FlowNode> n : rpst.getDirectSuccessors(node.getIRPTNodeAssociated())) {
			if(!n.getEntry().equals(node.getIRPTNodeAssociated().getExit()) && !n.getExit().equals(node.getIRPTNodeAssociated().getEntry()))
				return new ExtendedNode(n);
		}
		return null;
	}
	/**
	 * Returns the set of extended nodes that are successors of the input node
	 * 
	 * @param node input node to analyze
	 * @return the set of extended nodes that are successors of the input node
	 */
	public Collection<ExtendedNode> getDirectSuccessors(ExtendedNode node) {
		Collection<ExtendedNode> collection = new HashSet<ExtendedNode>();
		for (IRPSTNode<ControlFlow<FlowNode>, FlowNode> n : rpst.getDirectSuccessors(node.getIRPTNodeAssociated())) {
			if (node.getType().equals(TCType.BOND) && n.getFragment().size() == 2) {
				// In case (BOND,NODE) (NODE,BOND) => NODE
				n.getFragment().forEach(f -> {
					if (!f.getV1().getDescription().equals(BPMNLabel.XOR.toString())
							&& !f.getV1().getDescription().equals(BPMNLabel.AND.toString())
							&& f.getV1().getDescription().equals(BPMNLabel.EVENTBASEDG.toString()))
						collection.add(new ExtendedNode(f.getV1(), TCType.TRIVIAL));
					if (!f.getV2().getDescription().equals(BPMNLabel.XOR.toString())
							&& (!f.getV2().getDescription().equals(BPMNLabel.AND.toString()))
							&& !f.getV2().getDescription().equals(BPMNLabel.EVENTBASEDG.toString()))
						collection.add(new ExtendedNode(f.getV2(), TCType.TRIVIAL));
				});
			} else if (n.getType().equals(TCType.TRIVIAL)) {
				// In case NODE
				collection.add(new ExtendedNode(n.getEntry(), n.getType()));
				collection.add(new ExtendedNode(n.getExit(), n.getType()));
			} else {
				collection.add(new ExtendedNode(n));
			}
		}
		return collection;
	}

	/**
	 * Returns an ordered list of successors of the current node
	 * 
	 * @param node the extend node
	 * @return an ordered list of successors of the current node
	 */
	public List<ExtendedNode> getOrderedDirectSuccessors(ExtendedNode node) {
		List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> order = new ArrayList<IRPSTNode<ControlFlow<FlowNode>, FlowNode>>();
		List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list = rpst.getDirectSuccessors(node.getIRPTNodeAssociated())
				.stream().collect(Collectors.toList());
		order.add(list.get(0));
		FlowNode entry = list.get(0).getEntry();
		IRPSTNode<ControlFlow<FlowNode>, FlowNode> n;
		while ((n = findLeftSide(list, entry)) != null) {
			order.add(0, n);
			entry = n.getEntry();
		}
		FlowNode exit = list.get(0).getExit();
		while ((n = findRightSide(list, exit)) != null) {
			order.add(n);
			exit = n.getExit();
		}
		List<ExtendedNode> tmplist = generateExtendedNode(order);
		return tmplist;
	}

	private List<ExtendedNode> generateExtendedNode(List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list) {
		List<ExtendedNode> enlist = new ArrayList<ExtendedNode>();
		for (int i = 0; i < list.size(); i++) {
			if (!list.get(i).getType().equals(TCType.TRIVIAL)) {
				enlist.add(new ExtendedNode(list.get(i)));
			} else {
				FlowNode entry = list.get(i).getEntry();
				FlowNode exit = list.get(i).getExit();
				ExtendedNode entryen = new ExtendedNode(entry, list.get(i).getType());
				ExtendedNode exiten = new ExtendedNode(exit, list.get(i).getType());
				if (!(entry.getDescription().equals(BPMNLabel.XOR.toString())
						|| entry.getDescription().equals(BPMNLabel.AND.toString())
						|| entry.getDescription().equals(BPMNLabel.EVENTBASEDG.toString()))
						&& !enlist.contains(entryen))
					enlist.add(entryen);
				if (!(exit.getDescription().equals(BPMNLabel.XOR.toString())
						|| exit.getDescription().equals(BPMNLabel.AND.toString())
						|| exit.getDescription().equals(BPMNLabel.EVENTBASEDG.toString())) && !enlist.contains(exiten))
					enlist.add(exiten);
			}
		}
		return enlist;
	}

	private IRPSTNode<ControlFlow<FlowNode>, FlowNode> findLeftSide(
			List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list, FlowNode node) {
		for (IRPSTNode<ControlFlow<FlowNode>, FlowNode> n : list) {
			if (n.getExit().equals(node))
				return n;
		}
		return null;
	}

	private IRPSTNode<ControlFlow<FlowNode>, FlowNode> findRightSide(
			List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list, FlowNode node) {
		for (IRPSTNode<ControlFlow<FlowNode>, FlowNode> n : list) {
			if (n.getEntry().equals(node))
				return n;

		}
		return null;
	}

	@Override
	public String toString() {
		String s = "ExploitedRPST = " + traverRPST(getRoot());
		return s;
	}

	/**
	 * Traverse all the extended node printing out the result
	 * 
	 * @param node
	 * @return
	 */
	private String traverRPST(ExtendedNode node) {
		Collection<ExtendedNode> collection;
		if (node.getType().equals(TCType.POLYGON))
			collection = this.getOrderedDirectSuccessors(node);
		else
			collection = this.getDirectSuccessors(node);
		String s = node.toString();
		if (!collection.isEmpty()) {
			s = s + "(";
			for (ExtendedNode n : collection)
				s = s + traverRPST(n) + ",";
			s = s.substring(0, s.length() - 1) + ")";
		}
		return s;

	}

}
