package io;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import org.jbpt.algo.tree.rpst.IRPSTNode;
import org.jbpt.algo.tree.rpst.RPST;
import org.jbpt.algo.tree.tctree.TCType;
import org.jbpt.pm.ControlFlow;
import org.jbpt.pm.FlowNode;

public class ExploitedRPST {

	RPST<ControlFlow<FlowNode>, FlowNode> rpst;

	public ExploitedRPST(RPST<ControlFlow<FlowNode>, FlowNode> rpst) {
		this.rpst = rpst;
	}

	public ExtendedNode getRoot() {
		return new ExtendedNode(this.rpst.getRoot());
	}

	/*
	 * Get successor of the node is such a form that: POLYGON and BOUND are
	 * unchanged while TRIVIAL is seen as SINGLE NODES
	 */
	public Collection<ExtendedNode> getDirectSuccessors(ExtendedNode node) {
		Collection<ExtendedNode> collection = new HashSet<ExtendedNode>();
		for (IRPSTNode<ControlFlow<FlowNode>, FlowNode> n : rpst.getDirectSuccessors(node.getIRPTNodeAssociated())) {
			if (node.getType().equals(TCType.BOND) && n.getFragment().size() == 2) {
				n.getFragment().forEach(f -> {
					if (!f.getV1().getTag().equals(BPMNLabel.XOR) && (!f.getV1().getTag().equals(BPMNLabel.AND)))
						collection.add(new ExtendedNode(f.getV1(), f.getV1().getTag(), TCType.TRIVIAL, f.getV1().getId()));
					if (!f.getV2().getTag().equals(BPMNLabel.XOR) && (!f.getV2().getTag().equals(BPMNLabel.AND)))
						collection.add(new ExtendedNode(f.getV2(), f.getV2().getTag(), TCType.TRIVIAL, f.getV2().getId()));
				});

			} else if (n.getType().equals(TCType.TRIVIAL)) {
				collection
						.add(new ExtendedNode(n.getEntry(), n.getEntry().getTag(), n.getType(), n.getEntry().getId()));
				collection.add(new ExtendedNode(n.getExit(), n.getExit().getTag(), n.getType(), n.getExit().getId()));
			} else  {
				collection.add(new ExtendedNode(n));
			}
		}
		return collection;
	}

	public List<ExtendedNode> getOrderedDirectSuccessors(ExtendedNode node) {
		List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> order = new ArrayList<IRPSTNode<ControlFlow<FlowNode>, FlowNode>>();

		List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list = rpst.getDirectSuccessors(node.getIRPTNodeAssociated())
				.stream().collect(Collectors.toList());
		order.add(list.get(0));
		FlowNode entry = list.get(0).getEntry();
		IRPSTNode<ControlFlow<FlowNode>, FlowNode> n;
		while ((n = findLeftSide(list, entry)) != null) {
			order.add(0, n);
			entry = n.getEntry();
		}
		FlowNode exit = list.get(0).getExit();
		while ((n = findRightSide(list, exit)) != null) {
			order.add(n);
			exit = n.getExit();
		}
		List<ExtendedNode> tmplist = generateExtendedNode(order);
		return tmplist ;
	}

	private List<ExtendedNode> generateExtendedNode(List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list) {
		List<ExtendedNode> enlist = new ArrayList<ExtendedNode>();
		for (int i = 0; i < list.size(); i++) {
			if (!list.get(i).getType().equals(TCType.TRIVIAL)) {
				enlist.add(new ExtendedNode(list.get(i)));
			}else {
				FlowNode entry = list.get(i).getEntry();
				FlowNode exit = list.get(i).getExit();
				ExtendedNode entryen = new ExtendedNode(entry, entry.getTag(), list.get(i).getType(), entry.getId());
				ExtendedNode exiten = new ExtendedNode(exit, exit.getTag(), list.get(i).getType(), exit.getId());
				if (!(entry.getTag().equals(BPMNLabel.XOR) || entry.getTag().equals(BPMNLabel.AND))
						&& !enlist.contains(entryen))
					enlist.add(entryen);
				if (!(exit.getTag().equals(BPMNLabel.XOR) || exit.getTag().equals(BPMNLabel.AND))
						&& !enlist.contains(exiten))
					enlist.add(exiten);
			}
		}
		return enlist;
	}

	private IRPSTNode<ControlFlow<FlowNode>, FlowNode> findLeftSide(
			List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list, FlowNode node) {
		for (IRPSTNode<ControlFlow<FlowNode>, FlowNode> n : list) {
			if (n.getExit().equals(node))
				return n;
		}
		return null;
	}

	private IRPSTNode<ControlFlow<FlowNode>, FlowNode> findRightSide(
			List<IRPSTNode<ControlFlow<FlowNode>, FlowNode>> list, FlowNode node) {
		for (IRPSTNode<ControlFlow<FlowNode>, FlowNode> n : list) {
			if (n.getEntry().equals(node))
				return n;

		}
		return null;
	}

	@Override
	public String toString() {
		String s = "ExploitedRPST = " + traverRPST(getRoot()) ;		
		return s ;
	}
	
	private String traverRPST(ExtendedNode node) {
		Collection<ExtendedNode> collection;
		if(node.getType().equals(TCType.POLYGON))
			collection = this.getOrderedDirectSuccessors(node);
		else
			collection = this.getDirectSuccessors(node);
		
		String s = node.toString();
		if (!collection.isEmpty()) {
			s= s +"(";
			for (ExtendedNode n : collection)
				s = s +traverRPST(n) +",";
			s = s.substring(0, s.length()-1)+ ")";
		}
		return s;

	}

}
